"use strict";

define(['ably', 'shared_helper', 'async'], function(Ably, helper, async) {
	var exports = {},
		displayError = helper.displayError,
		utils = helper.Utils,
		mixin = utils.mixin,
		closeAndFinish = helper.closeAndFinish,
		monitorConnection = helper.monitorConnection,
		testOnAllTransports = helper.testOnAllTransports;

	exports.setupMessage = function(test) {
		test.expect(1);
		helper.setupApp(function(err) {
			if(err) {
				test.ok(false, displayError(err));
			} else {
				test.ok(true, 'setup app');
			}
			test.done();
		});
	};

	//testOnAllTransports(exports, 'reauth_authCallback', function(realtimeOpts) { return function(test) {
		//test.expect(5);
		//var realtime, rest = helper.AblyRest();
		//var firstTime = true;
		//var authCallback = function(tokenParams, callback) {
			//tokenParams.clientId = '*';
			//tokenParams.capability = firstTime ? {'wrong': ['*']} : {'right': ['*']};
			//firstTime = false;
			//rest.auth.requestToken(tokenParams, null, function(err, tokenDetails) {
				//if(err) {
					//test.ok(false, displayError(err));
					//closeAndFinish(test, realtime);
					//return;
				//}
				//callback(null, tokenDetails);
			//});
		//};

		//realtime = helper.AblyRealtime(mixin(realtimeOpts, {log: {level: 4}, authCallback: authCallback }));
		//realtime.connection.once('connected', function(){
			//test.ok(true, 'Verify connection connected');
			//var channel = realtime.channels.get('right');
			//channel.attach(function(err) {
				//test.ok(err, 'Check using first token, without channel attach capability');
				//test.equal(err.code, 40160, 'Check expected error code');

				//[> soon after connected, reauth <]
				//realtime.auth.authorize(null, null, function(err) {
					//test.ok(!err, err && displayError(err));
					//channel.attach(function(err) {
						//test.ok(!err, 'Check using second token, with channel attach capability');
						//closeAndFinish(test, realtime);
					//});
				//});
			//});
		//});
		//monitorConnection(test, realtime);
	//}});
	exports.connectionAttributes = function(test) {
		test.expect(6);
		var realtime;
		try {
			realtime = helper.AblyRealtime();
			realtime.connection.on('connected', function() {
				test.equal(realtime.connection.serial, -1, "verify serial is -1 on connect");
				test.equal(realtime.connection.recoveryKey, realtime.connection.key + ':' + realtime.connection.serial + ':' + realtime.connection.connectionManager.msgSerial, 'verify correct recovery key');

				var channel = realtime.channels.get('connectionattributes');
				channel.attach(function(err) {
					if(err) {
						test.ok(false, 'Attach failed with error: ' + displayError(err));
						closeAndFinish(test, realtime);
						return;
					}
					channel.subscribe(function() {
						setTimeout(function() {
							console.log("connectionAttributes test: connection serial is " + realtime.connection.serial)
							test.equal(realtime.connection.serial, 0, "verify serial is 0 after message received")
							test.equal(realtime.connection.recoveryKey, realtime.connection.key + ':' + realtime.connection.serial + ':' + realtime.connection.connectionManager.msgSerial, 'verify recovery key still correct');

							realtime.connection.close();
							realtime.connection.whenState('closed', function() {
								test.equal(realtime.connection.recoveryKey, null, 'verify recovery key null after close');
								closeAndFinish(test, realtime);
							});
						}, 0);
					});
					channel.publish("name", "data", function(err) {
						if(err) {
							test.ok(false, 'Publish failed with error: ' + displayError(err));
							closeAndFinish(test, realtime);
							return;
						}
					});
					test.equal(realtime.connection.serial, -1, "verify serial is -1 after publish but before message received")
				});
			});
			monitorConnection(test, realtime);
		} catch(e) {
			test.ok(false, 'test failed with exception: ' + e.stack);
			closeAndFinish(test, realtime);
		}
	};

	return module.exports = helper.withTimeout(exports);
});
